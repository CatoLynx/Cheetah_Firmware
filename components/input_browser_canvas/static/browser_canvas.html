<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Canvas</title>
    <link rel="icon" href="img/favicon.ico">
    <link rel="stylesheet" href="css/simple.css">
    <meta name='viewport' content='width=device-width, initial-scale=1' />
    <script src="js/jquery.min.js"></script>
    <script src="js/util.js"></script>
  </head>
  <body>
    <h2 id="hostname">&nbsp;</h2>
    <div id="pixel-container" style="display: none;">
      <canvas id="hidden-canvas" style="display: none;">
        If you can see this, it means that either your browser doesn't support HTML5 Canvas or you have JavaScript disabled.
        Try enabling JavaScript and reload the page.
      </canvas>
      <canvas id="pixel-canvas">
        If you can see this, it means that either your browser doesn't support HTML5 Canvas or you have JavaScript disabled.
        Try enabling JavaScript and reload the page.
      </canvas>
      <div>
        <label for="fg-color"><input type="color" id="fg-color" name="fg-color" value="#ffffff" /> Left Click</label>
        <label for="bg-color"><input type="color" id="bg-color" name="bg-color" value="#ffffff" /> Right Click</label>
        <input type="button" id="btn-clear" value="Clear" /><br />
        <input type="button" id="btn-invert-colors" value="Invert Colors" /><br />
        <label for="num-brush-size"><input type="number" min="1" max="50" value="1" id="num-brush-size" style="width: 4em;" /> Brush Size</label>
        <input type="file" id="file-image" accept="image/*" /><br />
        <label for="check-scale-down-image"><input type="checkbox" id="check-scale-down-image" /> Scale down</label>
        <label for="check-scale-up-image"><input type="checkbox" id="check-scale-up-image" /> Scale up</label>
        <label for="check-keep-aspect-ratio-image"><input type="checkbox" id="check-keep-aspect-ratio-image" /> Keep aspect ratio</label>
      </div>
    </div>
    <div id="bitmap-generator-container" style="display: none;">
      <label for="bitmap-generator-select">Bitmap generator</label>
      <select id="bitmap-generator-select" name="bitmap-generator-select"></select>
      <table id="bitmap-generator-params">
        <tbody></tbody>
      </table>
      <label for="bitmap-generator-preset-select">Presets</label>
      <select id="bitmap-generator-preset-select" name="bitmap-generator-preset-select"></select>
      <input type="button" id="btn-bitmap-generator-preset-save" value="Save" />
      <input type="button" id="btn-bitmap-generator-preset-delete" value="Delete" /><br />
    </div>
    <div id="text-container" style="display: none;">
      <label for="text-input">Text</label>
      <textarea id="text-input" name="text" style="font-family: monospace; font-size: 3em; overflow: hidden;"></textarea>
    </div>
    <div id="selection-container" style="display: none;"></div>
    <div id="brightness-container" style="display: none;">
      <label for="brightness-input">Brightness</label>
      <input type="range" id="brightness-input" name="brightness" min="0" max="255" value="255" />
      <input type="button" id="btn-save-brightness" value="Save as default" /><br />
    </div>
    <div id="shader-container" style="display: none;">
      <label for="shader-select">Shader</label>
      <select id="shader-select" name="shader-select"></select>
      <table id="shader-params">
        <tbody></tbody>
      </table>
    </div>
    <div id="transition-container" style="display: none;">
      <label for="transition-select">Transition</label>
      <select id="transition-select" name="transition-select"></select>
      <table id="transition-params">
        <tbody></tbody>
      </table>
    </div>
    <div>
      <label for="check-live-update"><input type="checkbox" id="check-live-update" /> Live Update</label>
      <input type="button" id="btn-update" value="Update" />
    </div>

    <script type="text/javascript">
      var _CANVASDEBUG = false;
      var _CANVASDEBUGINFO = {
        "type": "char_on_pixel",
        "driver": "char_16seg_led_ws281x_hybrid",
        "viewport_width_pixel": 74,
        "viewport_height_pixel": 101,
        "frame_width_pixel": 74,
        "frame_height_pixel": 101,
        "viewport_offset_x_pixel": 0,
        "viewport_offset_y_pixel": 0,
        "viewport_width_char": 1,
        "viewport_height_char": 1,
        "frame_width_char": 1,
        "frame_height_char": 1,
        "viewport_offset_x_char": 0,
        "viewport_offset_y_char": 0,
        "unitbuf_size": null,
        "output_buf_based_on": "char",
        "output_width": 1,
        "output_height": 1,
        "pixbuf_size": 74 * 101 * 3,
        "pixbuf_type": "24bpp",
        "textbuf_size": 2,
        "charbuf_size": 1,
        "brightness_control": true,
        "config": {},
        "quirks": ["combining_full_stop"]
      };
      
      var display_info = {};
      var shader_list = [];
      var transition_list = [];
      var bitmap_generator_list = [];
      var selectedShaderId = 0;
      var selectedTransitionId = 0;
      var selectedBitmapGeneratorId = 0;
      var bitmap_generator_presets = [];
      var selectedBitmapGeneratorPresetId = 0;
      var pixelSize = 10;
      var brushSize = 1;
      var baseColor = "#000000";
      var bgColor = "#000000";
      var gridColor = "#444444";
      var fgColor = "#ffffff";
      var gridLineWidth = 1;
      var pixels = new Array(0);
      var pixelCanvasButtonPressed = false;
      var pixelBufferUpdateInProgress = false;
      var textBufferUpdateInProgress = false;
      var unitBufferUpdateInProgress = false;
      var liveUpdate = false;
      
      /* PIXEL FUNCTIONS ################################################### */
      let Pixel = function(x, y, width, height, spacing, color) {
        this.getGridAlignedPos = function(num, size) {
          return num - (num % size);
        };

        this.x = this.getGridAlignedPos(x, width + spacing);
        this.y = this.getGridAlignedPos(y, height + spacing);
        this.buf_x = this.x / (width + spacing);
        this.buf_y = this.y / (height + spacing);
        this.width = width;
        this.height = height;
        this.fillColor = color;
      };

      Pixel.prototype.draw = function() {
        let canvas = $("#pixel-canvas")[0];
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = this.fillColor;
        ctx.strokeStyle = gridColor;
        ctx.fillRect(this.x, this.y, this.width, this.height);
      };

      Pixel.prototype.getIndex = function() {
        return this.buf_x * display_info["viewport_height_pixel"] + this.buf_y;
      }

      function drawLine(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
      }

      function drawPixelCanvas() {
        let canvas = $("#pixel-canvas")[0];
        canvas.width = (pixelSize * display_info["viewport_width_pixel"]) + (gridLineWidth * (display_info["viewport_width_pixel"] - 1));
        canvas.height = (pixelSize * display_info["viewport_height_pixel"]) + (gridLineWidth * (display_info["viewport_height_pixel"] - 1));
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = gridLineWidth;
        
        for (let i = pixelSize + (gridLineWidth / 2); i < canvas.width; i += (pixelSize + gridLineWidth)) {
            drawLine(ctx, i, 0, i, canvas.height);
        }

        for (let i = pixelSize + (gridLineWidth / 2); i < canvas.height; i += (pixelSize + gridLineWidth)) {
            drawLine(ctx, 0, i, canvas.width, i);
        }
        $("#btn-clear").click(clearCanvas);
        $("#btn-invert-colors").click(invertColors);
        $("#pixel-container").show();
        
        $("#pixel-canvas").contextmenu(onCanvasMouseRightClick);
        $("#pixel-canvas").mousedown(onCanvasMouseDown);
        $("#pixel-canvas").mousemove(onCanvasMouseMove);
        $("#pixel-canvas").mouseup(onCanvasMouseUp);
        $("#pixel-canvas").mouseout(onCanvasMouseOut);
      }
      
      function drawPixel(x, y, color) {
        let canvas = $("#pixel-canvas")[0];
        let margin = canvas.getBoundingClientRect();

        x -= margin.left;
        y -= margin.top;
        
        let offset = Math.round(brushSize * (pixelSize + gridLineWidth) / 2 - pixelSize / 2);

        for (let i = 0; i < brushSize; i++) {
          for (let j = 0; j < brushSize; j++) {
            let newPixel = new Pixel(x + i * (pixelSize + gridLineWidth) - offset, y + j * (pixelSize + gridLineWidth) - offset, pixelSize, pixelSize, gridLineWidth, color);
            newPixel.draw();
            let index = newPixel.getIndex();
            pixels[index] = color;
          }
        }
      }

      function updateCanvasFromPixels() {
        // Redraw interactive canvas from pixels array
        for (let x = 0; x < display_info["viewport_width_pixel"]; x++) {
          for (let y = 0; y < display_info["viewport_height_pixel"]; y++) {
            let i = x * display_info["viewport_height_pixel"] + y;
            let newPixel = new Pixel(x * (pixelSize + gridLineWidth), y * (pixelSize + gridLineWidth), pixelSize, pixelSize, gridLineWidth, pixels[i]);
            newPixel.draw();
          }
        }
      }

      function updatePixelsFromImage(imgData, width, height) {
        // Load image data into pixels array
        // Format: 32 bit RGBA, rows, left to right, top to bottom
        let fb_idx = 0;
        let pixel_idx = 0;
        for (let x = 0; x < display_info["frame_width_pixel"]; x++) {
          for (let y = 0; y < display_info["frame_height_pixel"]; y++) {
            if ((x >= display_info["viewport_offset_x_pixel"]) && (y >= display_info["viewport_offset_y_pixel"]) && (x < (display_info["viewport_width_pixel"] + display_info["viewport_offset_x_pixel"])) && (y < (display_info["viewport_height_pixel"] + display_info["viewport_offset_y_pixel"]))) {
              let img_x = (x - display_info["viewport_offset_x_pixel"]);
              let img_y = (y - display_info["viewport_offset_y_pixel"]);
              if (img_x < width && img_y < height) {
                fb_idx = (img_y * width + img_x) * 4;
                pixels[pixel_idx] = rgbToHex(imgData[fb_idx], imgData[fb_idx + 1], imgData[fb_idx + 2]);
              }
              pixel_idx++;
            }
          }
        }
      }

      function clearCanvas() {
        pixels = new Array(display_info["viewport_width_pixel"] * display_info["viewport_height_pixel"]);
        pixels.fill(bgColor);
        updateCanvasFromPixels();
        updatePixelBuffer(null);
      }

      function invertColors() {
        for (let x = 0; x < display_info["viewport_width_pixel"]; x++) {
          for (let y = 0; y < display_info["viewport_height_pixel"]; y++) {
            let i = x * display_info["viewport_height_pixel"] + y;
            pixels[i] = invertHexColor(pixels[i]);
          }
        }
        updateCanvasFromPixels();
        updatePixelBuffer(null);
      }

      function onCanvasMouseDown(event) {
        event.preventDefault();
        if(event.button == 0) drawPixel(event.clientX, event.clientY, fgColor);
        if(event.button == 2) drawPixel(event.clientX, event.clientY, bgColor);
        pixelCanvasButtonPressed = true;
        updatePixelBuffer(null);
      }

      function onCanvasMouseRightClick(event) {
        event.preventDefault();
      }

      function onCanvasMouseMove(event) {
        event.preventDefault();
        if((event.buttons == 1 || event.buttons == 2) && !pixelCanvasButtonPressed) {
          // Mouse has entered the canvas with button pressed
          pixelCanvasButtonPressed = true;
          updatePixelBuffer(null);
        }
        if(event.buttons == 1){
          drawPixel(event.clientX, event.clientY, fgColor);
        } else if(event.buttons == 2) {
          drawPixel(event.clientX, event.clientY, bgColor);
        }
      }

      function onCanvasMouseUp(event) {
        pixelCanvasButtonPressed = false;
        updatePixelBuffer(null);
      }

      function onCanvasMouseOut(event) {
        if(pixelCanvasButtonPressed) updatePixelBuffer(null);
        pixelCanvasButtonPressed = false;
      }

      function onForegroundColorChange(event) {
        fgColor = limitColorRange($("#fg-color").val());
        $("#fg-color").val(fgColor);
        localStorage.setItem("fgColor", fgColor);
      }
      
      function onBackgroundColorChange(event) {
        bgColor = limitColorRange($("#bg-color").val());
        $("#bg-color").val(bgColor);
        localStorage.setItem("bgColor", bgColor);
      }
      
      function onBrushSizeChange(event) {
        brushSize = $("#num-brush-size").val();
        localStorage.setItem("brushSize", brushSize);
      }

      function getPixelBufferFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "text",
          url: "/canvas/buffer/pixel",
          success: onGetPixelBufferFromDisplaySuccess,
          error: onGetPixelBufferFromDisplayError
        });
      }

      function onGetPixelBufferFromDisplaySuccess(data, textStatus, jqXHR) {
        if (display_info["type"] == "pixel" || display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") {
          let framebuf = Uint8Array.from(atob(data), c => c.charCodeAt(0));
          switch(display_info["pixbuf_type"]) {
            case "1bpp": {
              // TODO: Implement
              break;
            }

            case "8bpp": {
              let fb_idx = 0;
              let pixel_idx = 0;
              for (let x = 0; x < display_info["frame_width_pixel"]; x++) {
                for (let y = 0; y < display_info["frame_height_pixel"]; y++) {
                  if ((x >= display_info["viewport_offset_x_pixel"]) && (y >= display_info["viewport_offset_y_pixel"]) && (x < (display_info["viewport_width_pixel"] + display_info["viewport_offset_x_pixel"])) && (y < (display_info["viewport_height_pixel"] + display_info["viewport_offset_y_pixel"]))) {
                    pixels[pixel_idx++] = luminosityToHexColor(framebuf[fb_idx]);
                  }
                  fb_idx++;
                }
              }
              break;
            }

            case "24bpp": {
              let fb_idx = 0;
              let pixel_idx = 0;
              for (let x = 0; x < display_info["frame_width_pixel"]; x++) {
                for (let y = 0; y < display_info["frame_height_pixel"]; y++) {
                  if ((x >= display_info["viewport_offset_x_pixel"]) && (y >= display_info["viewport_offset_y_pixel"]) && (x < (display_info["viewport_width_pixel"] + display_info["viewport_offset_x_pixel"])) && (y < (display_info["viewport_height_pixel"] + display_info["viewport_offset_y_pixel"]))) {
                    pixels[pixel_idx++] = rgbToHex(framebuf[fb_idx], framebuf[fb_idx + 1], framebuf[fb_idx + 2]);
                  }
                  fb_idx += 3;
                }
              }
              break;
            }
          }
          updateCanvasFromPixels();
        }
      }

      function onGetPixelBufferFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting pixel buffer from display!");
        console.log(errorThrown);
      }

      function getPixelBuffer() {
        if (display_info["type"] == "pixel" || display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") {
          switch(display_info["pixbuf_type"]) {
            case "1bpp": {
              let framebuf = new Array(display_info["pixbuf_size"]);
              let fb_idx = 0;
              let pixel_idx = 0;
              for (let x = 0; x < display_info["frame_width_pixel"]; x++) {
                let byte = 0x00;
                for (let y = 0; y < display_info["frame_height_pixel"]; y++) {
                  let bit = y % 8;
                  if (!((x < display_info["viewport_offset_x_pixel"]) || (y < display_info["viewport_offset_y_pixel"]) || (x >= (display_info["viewport_width_pixel"] + display_info["viewport_offset_x_pixel"])) || (y >= (display_info["viewport_height_pixel"] + display_info["viewport_offset_y_pixel"])))) {
                    if (hexColorToLuminosity(pixels[pixel_idx]) > 127) byte |= (1 << bit);
                    pixel_idx++;
                  }
                  if ((bit == 7) || (y == display_info["frame_height_pixel"] - 1)) {
                    framebuf[fb_idx++] = byte;
                    byte = 0x00;
                  }
                }
              }
              return framebuf;
            }

            case "8bpp": {
              let framebuf = new Array(display_info["pixbuf_size"]);
              let fb_idx = 0;
              let pixel_idx = 0;
              for (let x = 0; x < display_info["frame_width_pixel"]; x++) {
                for (let y = 0; y < display_info["frame_height_pixel"]; y++) {
                  if ((x < display_info["viewport_offset_x_pixel"]) || (y < display_info["viewport_offset_y_pixel"]) || (x >= (display_info["viewport_width_pixel"] + display_info["viewport_offset_x_pixel"])) || (y >= (display_info["viewport_height_pixel"] + display_info["viewport_offset_y_pixel"]))) {
                    framebuf[fb_idx++] = 0;
                  } else {
                    framebuf[fb_idx++] = hexColorToLuminosity(pixels[pixel_idx]);
                    pixel_idx++;
                  }
                }
              }
              return framebuf;
            }

            case "24bpp": {
              let framebuf = new Array(display_info["pixbuf_size"]);
              let fb_idx = 0;
              let pixel_idx = 0;
              for (let x = 0; x < display_info["frame_width_pixel"]; x++) {
                for (let y = 0; y < display_info["frame_height_pixel"]; y++) {
                  if ((x < display_info["viewport_offset_x_pixel"]) || (y < display_info["viewport_offset_y_pixel"]) || (x >= (display_info["viewport_width_pixel"] + display_info["viewport_offset_x_pixel"])) || (y >= (display_info["viewport_height_pixel"] + display_info["viewport_offset_y_pixel"]))) {
                    framebuf[fb_idx++] = 0;
                    framebuf[fb_idx++] = 0;
                    framebuf[fb_idx++] = 0;
                  } else {
                    color = hexToRGB(pixels[pixel_idx]);
                    framebuf[fb_idx++] = color["r"];
                    framebuf[fb_idx++] = color["g"];
                    framebuf[fb_idx++] = color["b"];
                    pixel_idx++;
                  }
                }
              }
              return framebuf;
            }
          }
        }
      }

      function updatePixelBuffer(event) {
        // If live update is disabled, only allow events from the update button
        if (!liveUpdate) {
          if (event === null) return;
          if ($(event.target)[0] != $("#btn-update")[0]) return;
        }
        
        let fb = getPixelBuffer();
        buffer_b64 = btoa(String.fromCharCode.apply(null, fb));
        
        if (_CANVASDEBUG) {
          console.log(fb);
          console.log(buffer_b64);
          setTimeout(onUpdatePixelBufferSuccess, 250);
        } else {
          if(pixelBufferUpdateInProgress) return;
          pixelBufferUpdateInProgress = true;
          $.ajax({
            type: "POST",
            contentType: "text/plain",
            url: "/canvas/buffer/pixel",
            data: buffer_b64,
            success: onUpdatePixelBufferSuccess,
            error: onUpdatePixelBufferError
          });
        }
      }

      function onUpdatePixelBufferSuccess(data, textStatus, jqXHR) {
        pixelBufferUpdateInProgress = false;
        if(pixelCanvasButtonPressed) updatePixelBuffer(null);
      }

      function onUpdatePixelBufferError(jqXHR, textStatus, errorThrown) {
        pixelBufferUpdateInProgress = false;
        console.log("Error updating pixel buffer!");
        console.log(errorThrown);
      }
      
      function onImageFileSelected(event) {
        let file = event.target.files[0];
        if (file) {
          let reader = new FileReader();
          reader.onload = function(e) {
              let img = new Image();
              img.onload = function() {
                let maxWidth = display_info["viewport_width_pixel"];
                let maxHeight = display_info["viewport_height_pixel"];
                let width = img.width;
                let height = img.height;

                
                if (($("#check-scale-down-image").prop("checked") && (width > maxWidth || height > maxHeight)) || ($("#check-scale-up-image").prop("checked") && (width < maxWidth || height < maxHeight))) {
                  let widthRatio = maxWidth / width;
                  let heightRatio = maxHeight / height;
                  
                  if ($("#check-keep-aspect-ratio-image").prop("checked")) {
                    let scalingFactor = Math.min(widthRatio, heightRatio);
                    width *= scalingFactor;
                    height *= scalingFactor;
                  } else {
                    width *= widthRatio;
                    height *= heightRatio;
                  }
                }
                
                width = Math.round(width);
                height = Math.round(height);
                
                let canvas = $("#hidden-canvas")[0];
                let ctx = canvas.getContext("2d");
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                updatePixelsFromImage(imageData.data, width, height);
                updateCanvasFromPixels();
                updatePixelBuffer(null);
              };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      }

      /* ################################################################### */

      /* TEXT FUNCTIONS #################################################### */
      function drawTextInput() {
        $("#text-input").prop('cols', display_info["viewport_width_char"]);
        $("#text-input").prop('rows', display_info["viewport_height_char"]);
        $("#text-container").show();
        $("#text-input").on("input", onTextInputInput);
      }

      function onTextInputInput(event) {
        event.preventDefault();
        updateTextBuffer(event);
      }

      function getActualCharCount(str) {
        let count = 0;
        if (display_info["quirks"].includes("combining_full_stop")) {
          for (var i = 0; i < str.length; i++) {
            if (i == 0) {
              count++; // Always count first character
            } else {
              if (str[i] == ".") {
                if (str[i-1] == ".") count++; // Only count full stop if preceded by another full stop
              } else {
                count++; // Always count non full stop characters
              }
            }
          }
        } else {
          count = str.length;
        }
        return count;
      }

      function getTextBufferFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "text",
          url: "/canvas/buffer/text",
          success: onGetTextBufferFromDisplaySuccess,
          error: onGetTextBufferFromDisplayError
        });
      }

      function onGetTextBufferFromDisplaySuccess(data, textStatus, jqXHR) {
        if (display_info["type"] == "character" || display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") {
          let text = atob(data).replaceAll(/[ \x00]*$/g, "");
          $("#text-input").val(text);
        }
      }

      function onGetTextBufferFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting text buffer from display!");
        console.log(errorThrown);
      }

      function getTextBuffer() {
        if (display_info["type"] == "character" || display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") {
          let textbuf = new Array(display_info["textbuf_size"]);
          let val = $("#text-input").val();
          let valLen = val.length;
          for (let i = 0; i < valLen && i < display_info["textbuf_size"]; i++) {
            let code = val.charCodeAt(i);
            textbuf[i] = code > 255 ? 0 : code;
          }
          return textbuf;
        }
        
      }
      
      function updateTextBuffer(event) {
        // If live update is disabled, only allow events from the update button
        if (!liveUpdate) {
          if (event === null) return;
          if ($(event.target)[0] != $("#btn-update")[0]) return;
        }
        
        let fb = getTextBuffer();
        buffer_b64 = btoa(String.fromCharCode.apply(null, fb));
        
        if (_CANVASDEBUG) {
          console.log(fb);
          console.log(buffer_b64);
          setTimeout(onUpdateTextBufferSuccess, 250);
        } else {
          if(textBufferUpdateInProgress) return;
          textBufferUpdateInProgress = true;
          $.ajax({
            type: "POST",
            contentType: "text/plain",
            url: "/canvas/buffer/text",
            data: buffer_b64,
            success: onUpdateTextBufferSuccess,
            error: onUpdateTextBufferError
          });
        }
      }

      function onUpdateTextBufferSuccess(data, textStatus, jqXHR) {
        textBufferUpdateInProgress = false;
      }

      function onUpdateTextBufferError(jqXHR, textStatus, errorThrown) {
        textBufferUpdateInProgress = false;
        console.log("Error updating text buffer!");
        console.log(errorThrown);
      }

      /* ################################################################### */
      
      /* SELECTION FUNCTIONS ############################################### */
      function drawSelectionInput() {
        function getUnitByCoordinates(x, y) {
          let units = display_info["config"]["units"];
          for (const unit of units) {
            if ((x >= unit["x"] && x < (unit["x"] + (unit["width"] * unit["len"]))) && (y >= unit["y"] && y < (unit["y"] + unit["height"]))) {
              return unit;
            }
          }
          return null;
        }

        $("#selection-container").show();
        let config = display_info["config"];

        // Calculate the extent of the display
        let disp_width = 0;
        let disp_height = 0;
        for (var i = 0; i < config["units"].length; i++) {
          let unit = config["units"][i];
          unit["index"] = i;
          let unit_max_x = unit["x"] + (unit["width"] * unit["len"]);
          let unit_max_y = unit["y"] + unit["height"];
          if (unit_max_x > disp_width) disp_width = unit_max_x;
          if (unit_max_y > disp_height) disp_height = unit_max_y;
        }

        // Create the grid
        let table = $("<table>");
        table.css("table-layout", "fixed");
        
        // Add an invisible first row so we can use colspan
        let row = $("<tr>");
        row.css("background-color", "inherit");
        for (var x = 0; x < (disp_width + 1); x++) {
          let col = $("<td>");
          col.css("overflow", "hidden");
          col.css("padding", 0);
          col.css("border", "none");
          let div = $("<div>");
          div.css("width", "2rem");
          div.css("height", "2rem");
          col.append(div);
          row.append(col);
        }
        table.append(row);

        for (var y = 0; y < disp_height; y++) {
          let row = $("<tr>");
          row.css("background-color", "inherit");

          // Add an invisible first column so we can use rowspan
          let col = $("<td>");
          col.css("overflow", "hidden");
          col.css("padding", 0);
          col.css("border", "none");
          let div = $("<div>");
          div.css("width", "2rem");
          div.css("height", "2rem");
          col.append(div);
          row.append(col);

          for (var x = 0; x < disp_width; x++) {
            let unit = getUnitByCoordinates(x, y);
            if (unit == null) {
              let col = $("<td>");
              col.css("overflow", "hidden");
              col.css("padding", 0);
              col.css("border", "none");
              let div = $("<div>");
              div.css("width", "2rem");
              div.css("height", "2rem");
              col.append(div);
              row.append(col);
            } else {
              if (!("drawn" in unit) || unit["drawn"] == false) {
                let col = $("<td>");
                col.css("overflow", "hidden");
                col.css("padding", "0.5rem");
                col.css("border", "1px solid inherit");
                col.css("background-color", "#ddd");
                col.attr("colspan", (unit["width"] * unit["len"]));
                col.attr("rowspan", unit["height"]);
                let div = $("<div>");
                div.css("width", "100%");
                div.css("height", "100%");

                // This is where the input element gets added
                let input;
                if (unit["type"] == "text") {
                  input = $("<input type=\"text\">");
                  input.attr("maxlength", unit["len"]);
                  input.on("input", onTextInputInput);
                } else if(unit["type"] == "map") {
                  input = $("<select>");
                  input.change(updateUnitBuffer);
                  let map = config["maps"][unit["map"]];

                  // Add home position
                  let option = $("<option>");
                  option.attr("value", unit["home"]);
                  option.text("<Home>");
                  input.append(option);

                  for (const [key, value] of Object.entries(map)) {
                    let option = $("<option>");
                    option.attr("value", key);
                    option.text(value);
                    input.append(option);
                  }
                }
                input.attr("data-is-unit", "true");
                input.attr("data-unit-index", unit["index"]);
                input.css("margin", 0);
                input.css("width", "100%");
                div.append(input);

                col.append(div);
                row.append(col);
                unit["drawn"] = true;
              }
            }
          }
          table.append(row);
        }
        $("#selection-container").append(table);
      }

      function getUnitBufferFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "text",
          url: "/canvas/buffer/unit",
          success: onGetUnitBufferFromDisplaySuccess,
          error: onGetUnitBufferFromDisplayError
        });
      }

      function onGetUnitBufferFromDisplaySuccess(data, textStatus, jqXHR) {
        if (display_info["type"] == "selection") {
          let moduleData = Uint8Array.from(atob(data), c => c.charCodeAt(0));
          for (var i = 0; i < display_info["config"]["units"].length; i++) {
            let unit = display_info["config"]["units"][i];
            let input = $("[data-unit-index=" + i + "]");
            if (unit["type"] == "map") {
              input.val(moduleData[unit["addr"]]);
            } else if (unit["type"] == "text") {
              let text = "";
              let map = display_info["config"]["maps"][unit["map"]];
              for (var j = 0; j < unit["len"]; j++) {
                let code = moduleData[unit["addr"]+j];
                if (code in map) {
                  text += map[code];
                } else {
                  text += " ";
                }
              }
              input.val(text.trim());
            }
          }
        }
      }

      function onGetUnitBufferFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting unit buffer from display!");
        console.log(errorThrown);
      }

      function getUnitBuffer() {
        if (display_info["type"] == "selection") {
          let framebuf = new Array(display_info["unitbuf_size"]);
          let inputs = $("[data-is-unit=true]");
          for (const input of inputs) {
            let unit_index = parseInt($(input).attr("data-unit-index"));
            let unit = display_info["config"]["units"][unit_index];
            let value = $(input).val();
            if (unit["type"] == "text") {
              // Convert text to positions using mapping
              if (unit["flags"].includes("upper")) value = value.toUpperCase();
              if (unit["flags"].includes("lower")) value = value.toLowerCase();

              let map = swap(display_info["config"]["maps"][unit["map"]]);
              for (var i = 0; i < unit["len"]; i++) {
                framebuf[unit["addr"] + i] = parseInt(map[value[i]]) || 0;
              }
            } else if(unit["type"] == "map") {
              // Already mapped
              framebuf[unit["addr"]] = parseInt(value) || 0;
            }
          }
          return framebuf;
        }
      }

      function updateUnitBuffer(event) {
        // If live update is disabled, only allow events from the update button
        if (!liveUpdate) {
          if (event === null) return;
          if ($(event.target)[0] != $("#btn-update")[0]) return;
        }
        
        let fb = getUnitBuffer();
        buffer_b64 = btoa(String.fromCharCode.apply(null, fb));
        
        if (_CANVASDEBUG) {
          console.log(fb);
          console.log(buffer_b64);
          setTimeout(onUpdateUnitBufferSuccess, 250);
        } else {
          if(unitBufferUpdateInProgress) return;
          unitBufferUpdateInProgress = true;
          $.ajax({
            type: "POST",
            contentType: "text/plain",
            url: "/canvas/buffer/text",
            data: buffer_b64,
            success: onUpdateUnitBufferSuccess,
            error: onUpdateUnitBufferError
          });
        }
      }

      function onUpdateUnitBufferSuccess(data, textStatus, jqXHR) {
        unitBufferUpdateInProgress = false;
      }

      function onUpdateUnitBufferError(jqXHR, textStatus, errorThrown) {
        unitBufferUpdateInProgress = false;
        console.log("Error updating unit buffer!");
        console.log(errorThrown);
      }

      /* ################################################################### */
      
      /* BRIGHTNESS FUNCTIONS ############################################## */
      function drawBrightnessControl() {
        $("#brightness-container").show();
      }

      function onBrightnessChange(event) {
        updateBrightness(false);
      }

      function getBrightnessFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/brightness.json",
          success: onGetBrightnessFromDisplaySuccess,
          error: onGetBrightnessFromDisplayError
        });
      }

      function updateBrightness(save) {
        let brightness = parseInt($("#brightness-input").val());
        if (_CANVASDEBUG) {
          console.log("Setting brightness to " + brightness);
        } else {
          $.ajax({
            type: "POST",
            contentType: "application/json",
            url: "/canvas/brightness.json",
            data: JSON.stringify({"brightness": brightness, "saveDefault": !!save}),
            success: onSetBrightnessSuccess,
            error: onSetBrightnessError
          });
        }
      }

      function onGetBrightnessFromDisplaySuccess(data, textStatus, jqXHR) {
        $("#brightness-input").val(data["brightness"]);
      }

      function onGetBrightnessFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting brightness from display!");
        console.log(errorThrown);
      }

      function onSetBrightnessSuccess(data, textStatus, jqXHR) {
        
      }

      function onSetBrightnessError(jqXHR, textStatus, errorThrown) {
        console.log("Error setting brightness!");
        console.log(errorThrown);
      }

      function saveDefaultBrightness(event) {
        updateBrightness(true);
      }

      /* ################################################################### */
      
      /* SHADER FUNCTIONS ################################################## */
      function drawShaderControl() {
        shader_list.forEach(function(shader, i) {
          $('#shader-select').append($('<option>', {
              value: i,
              text: shader["name"]
          }));
        });

        drawShaderParameters();
        $("#shader-select").change(onShaderSelectChange);
        $("#shader-container").show();
      }

      function drawShaderParameters() {
        var selectedShader = shader_list[selectedShaderId];
        var params = selectedShader["params"];
        $("#shader-params").find("tbody").empty();
        if(!params) return;

        for (var paramName of Object.keys(params)) {
          var paramData = params[paramName];

          var field_element = $('<input type="' + paramData["type"] + '">');
          field_element.prop("name", paramName);
          field_element.prop("id", "shader-param-" + paramName);
          for (var propName of Object.keys(paramData)) {
            if (propName == "type") continue;
            field_element.prop(propName, paramData[propName]);
          }
          field_element.change(updateShader);

          var td_name = $("<td>" + paramName + "</td>");
          var td_field = $("<td>").append(field_element);

          switch (paramData["type"]) {
            case "range": {
              var value_display = $('<span>');
              value_display.prop("id", "shader-param-display-" + paramName);
              value_display.text(field_element.val());
              field_element.change(function(event) {
                $("#shader-param-display-" + $(event.target).prop("name")).text($(event.target).val());
              });
              td_field.append(value_display);
              break;
            }

            case "color": {
              field_element.val("#ffffff");
            }
          }

          var tr = $("<tr>").append(td_name).append(td_field);
          $("#shader-params").find("tbody").append(tr);
        }
      }

      function getShaders() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/shaders.json",
          success: onGetShadersSuccess,
          error: onGetShadersError
        });
      }

      function getShaderFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/shader.json",
          success: onGetShaderFromDisplaySuccess,
          error: onGetShaderFromDisplayError
        });
      }

      function getShaderData() {
        var data = {
          shader: parseInt($("#shader-select").val()),
          params: {}
        };

        var inputs = $("#shader-params input");
        for (var i = 0; i < inputs.length; i++) {
          var field_name = $(inputs[i]).prop("name");
          var field_type = $(inputs[i]).prop("type");
          if (["range", "number"].includes(field_type)) {
            // Numerical field
            var field_value = parseInt($(inputs[i]).val());
          } else if (field_type == "color") {
            var field_value = hexToRGB($(inputs[i]).val());
          } else if (field_type == "checkbox") {
            var field_value = $(inputs[i]).prop("checked");
          } else {
            var field_value = $(inputs[i]).val();
          }
          data["params"][field_name] = field_value;
        }
        return data;
      }

      function setShaderData(data) {
        $("#shader-select").val(data["shader"]);
        $("#shader-select").trigger("change");
        let shader_info = shader_list[data["shader"]];

        for (var paramName of Object.keys(data["params"])) {
          let paramInfo = shader_info["params"][paramName];
          let paramCtrl = $("#shader-param-" + paramName);

          if (paramInfo["type"] == "color") {
            paramCtrl.val(rgbToHex(data["params"][paramName]["r"], data["params"][paramName]["g"], data["params"][paramName]["b"]));
          } else {
            paramCtrl.val(data["params"][paramName]);
          }
          paramCtrl.trigger("change");
        }
      }

      function updateShader() {
        var payload = getShaderData();

        if (_CANVASDEBUG) {
          console.log("Shader data:");
          console.log(payload);
        } else {
          $.ajax({
            type: "POST",
            contentType: "application/json",
            url: "/canvas/shader.json",
            data: JSON.stringify(payload),
            success: onSetShaderSuccess,
            error: onSetShaderError
          });
        }
      }

      function onShaderSelectChange(event) {
        selectedShaderId = parseInt($("#shader-select").val());
        drawShaderParameters();
        updateShader();
      }

      function onGetShadersSuccess(data, textStatus, jqXHR) {
        if(!("shaders" in data)) return;
        shader_list = data["shaders"];
        drawShaderControl();
        getShaderFromDisplay();
      }

      function onGetShadersError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting shaders!");
        console.log(errorThrown);
      }

      function onSetShaderSuccess(data, textStatus, jqXHR) {
        
      }

      function onSetShaderError(jqXHR, textStatus, errorThrown) {
        console.log("Error setting shader!");
        console.log(errorThrown);
      }
      
      function onGetShaderFromDisplaySuccess(data, textStatus, jqXHR) {
        if ($.isEmptyObject(data)) return;
        setShaderData(data);
      }

      function onGetShaderFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting shader from display!");
        console.log(errorThrown);
      }
      
      /* ################################################################### */
      
      /* TRANSITION FUNCTIONS ############################################## */
      function drawTransitionControl() {
        transition_list.forEach(function(transition, i) {
          $('#transition-select').append($('<option>', {
              value: i,
              text: transition["name"]
          }));
        });

        drawTransitionParameters();
        $("#transition-select").change(onTransitionSelectChange);
        $("#transition-container").show();
      }

      function drawTransitionParameters() {
        var selectedTransition = transition_list[selectedTransitionId];
        var params = selectedTransition["params"];
        $("#transition-params").find("tbody").empty();
        if(!params) return;

        for (var paramName of Object.keys(params)) {
          var paramData = params[paramName];

          var field_element = $('<input type="' + paramData["type"] + '">');
          field_element.prop("name", paramName);
          field_element.prop("id", "transition-param-" + paramName);
          for (var propName of Object.keys(paramData)) {
            if (propName == "type") continue;
            field_element.prop(propName, paramData[propName]);
          }
          field_element.change(updateTransition);

          var td_name = $("<td>" + paramName + "</td>");
          var td_field = $("<td>").append(field_element);

          switch (paramData["type"]) {
            case "range": {
              var value_display = $('<span>');
              value_display.prop("id", "transition-param-display-" + paramName);
              value_display.text(field_element.val());
              field_element.change(function(event) {
                $("#transition-param-display-" + $(event.target).prop("name")).text($(event.target).val());
              });
              td_field.append(value_display);
              break;
            }

            case "color": {
              field_element.val("#ffffff");
            }
          }

          var tr = $("<tr>").append(td_name).append(td_field);
          $("#transition-params").find("tbody").append(tr);
        }
      }

      function getTransitions() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/transitions.json",
          success: onGetTransitionsSuccess,
          error: onGetTransitionsError
        });
      }

      function getTransitionFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/transition.json",
          success: onGetTransitionFromDisplaySuccess,
          error: onGetTransitionFromDisplayError
        });
      }

      function getTransitionData() {
        var data = {
          transition: parseInt($("#transition-select").val()),
          params: {}
        };

        var inputs = $("#transition-params input");
        for (var i = 0; i < inputs.length; i++) {
          var field_name = $(inputs[i]).prop("name");
          var field_type = $(inputs[i]).prop("type");
          if (["range", "number"].includes(field_type)) {
            // Numerical field
            var field_value = parseInt($(inputs[i]).val());
          } else if (field_type == "color") {
            var field_value = hexToRGB($(inputs[i]).val());
          } else if (field_type == "checkbox") {
            var field_value = $(inputs[i]).prop("checked");
          } else {
            var field_value = $(inputs[i]).val();
          }
          data["params"][field_name] = field_value;
        }
        return data;
      }

      function setTransitionData(data) {
        $("#transition-select").val(data["transition"]);
        $("#transition-select").trigger("change");
        let transition_info = transition_list[data["transition"]];

        for (var paramName of Object.keys(data["params"])) {
          let paramInfo = transition_info["params"][paramName];
          let paramCtrl = $("#transition-param-" + paramName);

          if (paramInfo["type"] == "color") {
            paramCtrl.val(rgbToHex(data["params"][paramName]["r"], data["params"][paramName]["g"], data["params"][paramName]["b"]));
          } else {
            paramCtrl.val(data["params"][paramName]);
          }
          paramCtrl.trigger("change");
        }
      }

      function updateTransition() {
        var payload = getTransitionData();

        if (_CANVASDEBUG) {
          console.log("Transition data:");
          console.log(payload);
        } else {
          $.ajax({
            type: "POST",
            contentType: "application/json",
            url: "/canvas/transition.json",
            data: JSON.stringify(payload),
            success: onSetTransitionSuccess,
            error: onSetTransitionError
          });
        }
      }

      function onTransitionSelectChange(event) {
        selectedTransitionId = parseInt($("#transition-select").val());
        drawTransitionParameters();
        updateTransition();
      }

      function onGetTransitionsSuccess(data, textStatus, jqXHR) {
        if(!("transitions" in data)) return;
        transition_list = data["transitions"];
        drawTransitionControl();
        getTransitionFromDisplay();
      }

      function onGetTransitionsError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting transitions!");
        console.log(errorThrown);
      }

      function onSetTransitionSuccess(data, textStatus, jqXHR) {
        
      }

      function onSetTransitionError(jqXHR, textStatus, errorThrown) {
        console.log("Error setting transition!");
        console.log(errorThrown);
      }
      
      function onGetTransitionFromDisplaySuccess(data, textStatus, jqXHR) {
        if ($.isEmptyObject(data)) return;
        setTransitionData(data);
      }

      function onGetTransitionFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting transition from display!");
        console.log(errorThrown);
      }
      
      /* ################################################################### */
      
      /* BITMAP GENERATOR FUNCTIONS ######################################## */
      function drawBitmapGeneratorControl() {
        bitmap_generator_list.forEach(function(bitmapGenerator, i) {
          $('#bitmap-generator-select').append($('<option>', {
              value: i,
              text: bitmapGenerator["name"]
          }));
        });

        drawBitmapGeneratorPresetSelect();
        drawBitmapGeneratorParameters();
        $("#bitmap-generator-select").change(onBitmapGeneratorSelectChange);
        $("#bitmap-generator-preset-select").change(onBitmapGeneratorPresetSelectChange);
        $("#btn-bitmap-generator-preset-save").click(addBitmapGeneratorPreset);
        $("#btn-bitmap-generator-preset-delete").click(deleteBitmapGeneratorPreset);
        $("#bitmap-generator-container").show();
      }
      
      function drawBitmapGeneratorPresetSelect() {
        $('#bitmap-generator-preset-select').find('option').remove();
        bitmap_generator_presets.forEach(function(bitmapGeneratorPreset, i) {
          $('#bitmap-generator-preset-select').append($('<option>', {
              value: i,
              text: bitmapGeneratorPreset["name"]
          }));
        });
      }

      function drawBitmapGeneratorParameters() {
        var selectedBitmapGenerator = bitmap_generator_list[selectedBitmapGeneratorId];
        var params = selectedBitmapGenerator["params"];
        $("#bitmap-generator-params").find("tbody").empty();
        if(!params) return;

        for (var paramName of Object.keys(params)) {
          var paramData = params[paramName];

          var field_element = $('<input type="' + paramData["type"] + '">');
          field_element.prop("name", paramName);
          field_element.prop("id", "bitmap-generator-param-" + paramName);
          for (var propName of Object.keys(paramData)) {
            if (propName == "type") continue;
            field_element.prop(propName, paramData[propName]);
          }
          field_element.change(updateBitmapGenerator);

          var td_name = $("<td>" + paramName + "</td>");
          var td_field = $("<td>").append(field_element);

          switch (paramData["type"]) {
            case "range": {
              var value_display = $('<span>');
              value_display.prop("id", "bitmap-generator-param-display-" + paramName);
              value_display.text(field_element.val());
              field_element.change(function(event) {
                $("#bitmap-generator-param-display-" + $(event.target).prop("name")).text($(event.target).val());
              });
              td_field.append(value_display);
              break;
            }

            case "color": {
              field_element.val("#ffffff");
            }
          }

          var tr = $("<tr>").append(td_name).append(td_field);
          $("#bitmap-generator-params").find("tbody").append(tr);
        }
      }

      function getBitmapGenerators() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/bitmap_generators.json",
          success: onGetBitmapGeneratorsSuccess,
          error: onGetBitmapGeneratorsError
        });
      }

      function getBitmapGeneratorFromDisplay() {
        $.ajax({
          type: "GET",
          dataType: "json",
          url: "/canvas/bitmap_generator.json",
          success: onGetBitmapGeneratorFromDisplaySuccess,
          error: onGetBitmapGeneratorFromDisplayError
        });
      }

      function getBitmapGeneratorData() {
        var data = {
          generator: parseInt($("#bitmap-generator-select").val()),
          params: {}
        };

        var inputs = $("#bitmap-generator-params input");
        for (var i = 0; i < inputs.length; i++) {
          var field_name = $(inputs[i]).prop("name");
          var field_type = $(inputs[i]).prop("type");
          if (["range", "number"].includes(field_type)) {
            // Numerical field
            var field_value = parseInt($(inputs[i]).val());
          } else if (field_type == "color") {
            var field_value = hexToRGB($(inputs[i]).val());
          } else if (field_type == "checkbox") {
            var field_value = $(inputs[i]).prop("checked");
          } else {
            var field_value = $(inputs[i]).val();
          }
          data["params"][field_name] = field_value;
        }
        return data;
      }

      function setBitmapGeneratorData(data) {
        $("#bitmap-generator-select").val(data["generator"]);
        selectedBitmapGeneratorId = parseInt($("#bitmap-generator-select").val());
        drawBitmapGeneratorParameters();
        let bitmap_generator_info = bitmap_generator_list[data["generator"]];

        for (var paramName of Object.keys(data["params"])) {
          let paramInfo = bitmap_generator_info["params"][paramName];
          let paramCtrl = $("#bitmap-generator-param-" + paramName);

          if (paramInfo["type"] == "color") {
            paramCtrl.val(rgbToHex(data["params"][paramName]["r"], data["params"][paramName]["g"], data["params"][paramName]["b"]));
          } else {
            paramCtrl.val(data["params"][paramName]);
          }
        }
        updateBitmapGenerator();
      }

      function updateBitmapGenerator() {
        var payload = getBitmapGeneratorData();

        if (_CANVASDEBUG) {
          console.log("Bitmap generator data:");
          console.log(payload);
        } else {
          $.ajax({
            type: "POST",
            contentType: "application/json",
            url: "/canvas/bitmap_generator.json",
            data: JSON.stringify(payload),
            success: onSetBitmapGeneratorSuccess,
            error: onSetBitmapGeneratorError
          });
        }
      }

      function onBitmapGeneratorSelectChange(event) {
        selectedBitmapGeneratorId = parseInt($("#bitmap-generator-select").val());
        drawBitmapGeneratorParameters();
        updateBitmapGenerator();
      }

      function onBitmapGeneratorPresetSelectChange(event) {
        selectedBitmapGeneratorPresetId = parseInt($("#bitmap-generator-preset-select").val());
        let preset = bitmap_generator_presets[selectedBitmapGeneratorPresetId];
        setBitmapGeneratorData(preset["data"]);
      }

      function onGetBitmapGeneratorsSuccess(data, textStatus, jqXHR) {
        if(!("generators" in data)) return;
        bitmap_generator_list = data["generators"];
        loadBitmapGeneratorPresets();
        drawBitmapGeneratorControl();
        getBitmapGeneratorFromDisplay();
      }

      function onGetBitmapGeneratorsError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting bitmap generators!");
        console.log(errorThrown);
      }

      function onSetBitmapGeneratorSuccess(data, textStatus, jqXHR) {
        
      }

      function onSetBitmapGeneratorError(jqXHR, textStatus, errorThrown) {
        console.log("Error setting bitmap generator!");
        console.log(errorThrown);
      }
      
      function onGetBitmapGeneratorFromDisplaySuccess(data, textStatus, jqXHR) {
        if ($.isEmptyObject(data)) return;
        setBitmapGeneratorData(data);
      }

      function onGetBitmapGeneratorFromDisplayError(jqXHR, textStatus, errorThrown) {
        console.log("Error getting bitmap generator from display!");
        console.log(errorThrown);
      }
      
      function addBitmapGeneratorPreset(event) {
        let name = prompt("Please enter a name for the new preset.");
        if (!name) return;
        let data = getBitmapGeneratorData();
        let preset = {"name": name, "data": data};
        bitmap_generator_presets.push(preset);
        saveBitmapGeneratorPresets();
        drawBitmapGeneratorPresetSelect();
      }
      
      function deleteBitmapGeneratorPreset(event) {
        let i = parseInt($("#bitmap-generator-preset-select").val());
        if (i == 0) return;
        bitmap_generator_presets.splice(i, 1);
        saveBitmapGeneratorPresets();
        drawBitmapGeneratorPresetSelect();
      }
      
      function loadBitmapGeneratorPresets() {
        bitmap_generator_presets = [{"name": "None", "data": {}}];
        bitmap_generator_presets = bitmap_generator_presets.concat(JSON.parse(localStorage.getItem("bitmapGeneratorPresets") || "[]"));
      }
      
      function saveBitmapGeneratorPresets() {
        // Skip first element (None)
        localStorage.setItem("bitmapGeneratorPresets", JSON.stringify(bitmap_generator_presets.slice(1)));
      }
      
      /* ################################################################### */

      /* UTILITY FUNCTIONS ################################################# */
      function padZero(str, len) {
        len = len || 2;
        var zeros = new Array(len).join('0');
        return (zeros + str).slice(-len);
      }

      function invertHexColor(hex) {
        if (hex.indexOf('#') === 0) {
          hex = hex.slice(1);
        }
        // convert 3-digit hex to 6-digits.
        if (hex.length === 3) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        if (hex.length !== 6) {
          throw new Error('Invalid HEX color.');
        }
        // invert color components
        var r = (255 - parseInt(hex.slice(0, 2), 16)).toString(16),
            g = (255 - parseInt(hex.slice(2, 4), 16)).toString(16),
            b = (255 - parseInt(hex.slice(4, 6), 16)).toString(16);
        // pad each with zeros and return
        return '#' + padZero(r) + padZero(g) + padZero(b);
      }

      function hexToRGB(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      
      function componentToHex(c) {
        let hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      }
      
      function rgbToHex(r, g, b) {
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
      }
      
      function limitColorRange(color) {
        switch(display_info["pixbuf_type"]) {
          case "1bpp": {
            let lum = hexColorToLuminosity(color);
            return lum > 127 ? "#ffffff" : "#000000";
          }

          case "8bpp": {
            let lum = hexColorToLuminosity(color);
            return luminosityToHexColor(lum);
          }
          
          default:
          case "24bpp": {
            return color;
          }
        }
      }

      function hexColorToLuminosity(color) {
        let rgb = hexToRGB(color);
        let lum = Math.round(rgb["r"] * 0.2126 + rgb["g"] * 0.7152 + rgb["b"] * 0.0722);
        return lum > 255 ? 255 : lum;
      }

      function luminosityToHexColor(luminosity) {
        return rgbToHex(luminosity, luminosity, luminosity);
      }

      function swap(obj) {
        // Swap keys and values in object
        var ret = {};
        for(var key in obj){
          ret[obj[key]] = key;
        }
        return ret;
      }

      /* ################################################################### */

      /* GENERAL FUNCTIONS ################################################# */
      function getDisplayInfo() {
        if (_CANVASDEBUG) {
          onGetDisplayInfoSuccess(_CANVASDEBUGINFO);
        } else {
          $.ajax({
            type: "GET",
            dataType: "json",
            url: "/info/display.json",
            success: onGetDisplayInfoSuccess,
            error: onGetDisplayInfoError
          });
        }
      }

      function onGetDisplayInfoSuccess(data, textStatus, jqXHR) {
        display_info = data;
        if(display_info["type"] == "pixel") {
          pixels = new Array(data["viewport_width_pixel"] * data["viewport_height_pixel"]);
          pixels.fill(bgColor);
          drawPixelCanvas();
          getPixelBufferFromDisplay();
        } else if(display_info["type"] == "character") {
          drawTextInput();
          getTextBufferFromDisplay();
        } else if(display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") {
          pixels = new Array(data["viewport_width_pixel"] * data["viewport_height_pixel"]);
          pixels.fill(bgColor);
          drawPixelCanvas();
          drawTextInput();
          getPixelBufferFromDisplay();
          getTextBufferFromDisplay();
        } else if(display_info["type"] == "selection") {
          drawSelectionInput();
          getUnitBufferFromDisplay();
        } else {
          console.log("ERROR: Unsupported display type \"" + display_info["type"] + "\"");
          return;
        }

        if(display_info["brightness_control"]) {
          getBrightnessFromDisplay();
          drawBrightnessControl();
          $("#brightness-input").change(onBrightnessChange);
          $("#btn-save-brightness").click(saveDefaultBrightness);
        }
      }

      function onGetDisplayInfoError(jqXHR, textStatus, errorThrown) {
        console.log("Error querying display info!");
        console.log(errorThrown);
        $("body").html("<div style='color: #ff3333; font-weight: bold; font-size: 3vw;'>Error communicating with display!</div>");
      }

      function onGetDeviceInfoSuccess(data, textStatus, jqXHR) {
        document.title += " - " + data['hostname'];
        $("#hostname").text(data['hostname']);
      }

      function onGetDeviceInfoError(jqXHR, textStatus, errorThrown) {
        
      }

      function onLiveUpdateChange(event) {
        liveUpdate = $("#check-live-update").prop("checked");
        localStorage.setItem("liveUpdate", liveUpdate);
        if (liveUpdate) {
          $("#btn-update").hide();
        } else {
          $("#btn-update").show();
        }
      }

      function updateAllBuffers(event) {
        if (display_info["type"] == "pixel" || display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") updatePixelBuffer(event);
        if (display_info["type"] == "character" || display_info["type"] == "char_on_pixel" || display_info["type"] == "pixel_on_char") updateTextBuffer(event);
        if (display_info["type"] == "selection") updateUnitBuffer(event);
      }

      function onReady() {
        getDeviceInfo(onGetDeviceInfoSuccess, onGetDeviceInfoError);
        getDisplayInfo();
        getShaders();
        getTransitions();
        getBitmapGenerators();
        fgColor = limitColorRange(localStorage.getItem("fgColor") || fgColor);
        bgColor = limitColorRange(localStorage.getItem("bgColor") || bgColor);
        brushSize = localStorage.getItem("brushSize") || brushSize;
        liveUpdate = (localStorage.getItem("liveUpdate") == "true") || liveUpdate;
        $("#check-live-update").change(onLiveUpdateChange);
        $("#btn-update").click(updateAllBuffers);
        $("#fg-color").val(fgColor);
        $("#bg-color").val(bgColor);
        $("#num-brush-size").val(brushSize);
        $("#check-live-update").prop("checked", liveUpdate);
        onLiveUpdateChange(null);
        $("#fg-color").change(onForegroundColorChange);
        $("#bg-color").change(onBackgroundColorChange);
        $("#num-brush-size").change(onBrushSizeChange);
        $("#file-image").change(onImageFileSelected);
      }

      /* ################################################################### */
      
      $(document).ready(onReady);
    </script>
  </body>
</html>
